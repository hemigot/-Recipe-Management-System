# -*- coding: utf-8 -*-
"""Untitled12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ULzhEvKGNziWLtk13sHiwYC3KlPNs68g
"""

import pandas as pd
import os
from google.colab import files

# Upload file in Colab
uploaded = files.upload()

# Load the CSV after upload
df = pd.read_csv("/content/Projectdta.csv")
df.head()

# prompt: Add new recipes with detailed steps and ingredients

import pandas as pd
import os
from google.colab import files

# Assuming 'df' is already defined from the previous code block

new_recipes = {
    'Recipe Name': ['Chicken Stir-Fry', 'Pasta Carbonara'],
    'Ingredients': [
        'Chicken breast, broccoli, soy sauce, garlic, ginger, rice',
        'Spaghetti, pancetta, eggs, Pecorino Romano cheese, black pepper'
    ],
    'Steps': [
        '1. Cut chicken into bite-sized pieces. 2. Stir-fry garlic and ginger. 3. Add chicken and cook until browned. 4. Add broccoli and stir-fry until tender. 5. Pour in soy sauce and mix well. 6. Serve with rice.',
        '1. Cook spaghetti according to package directions. 2. Cook pancetta until crispy. 3. Whisk eggs, cheese, and black pepper together. 4. Add cooked spaghetti to the pancetta and toss with the egg mixture. 5. Serve immediately.'
    ],
     'Cuisine': ['Chinese', 'Italian'],
    'Prep Time (minutes)': [20, 25],
    'Cook Time (minutes)': [15, 10]
}

new_df = pd.DataFrame(new_recipes)
df = pd.concat([df, new_df], ignore_index=True)

print(df.tail()) #check if new recipes have been added

# prompt: Update existing recipes

# Assuming 'df' is already defined from the previous code block

# Sample updated recipes (replace with your actual updates)
updates = {
    'Recipe Name': ['Chicken Stir-Fry'],  # Recipe names to update
    'Ingredients': ['Chicken breast, bell peppers, onions, soy sauce, oyster sauce'],
    'Steps': ['1. Marinate chicken. 2. Stir-fry veggies. 3. Add chicken and stir-fry until cooked. 4. Add sauces and mix well.'],
    'Cuisine': ['Chinese'], #add any other columns with its respective values
    'Prep Time (minutes)': [25],
    'Cook Time (minutes)': [10]
}
update_df = pd.DataFrame(updates)

# Use .loc to update rows based on 'Recipe Name'
for index, row in update_df.iterrows():
    recipe_name = row['Recipe Name']
    df.loc[df['Recipe Name'] == recipe_name, ['Ingredients', 'Steps', 'Cuisine', 'Prep Time (minutes)', 'Cook Time (minutes)']] = row[['Ingredients', 'Steps', 'Cuisine', 'Prep Time (minutes)', 'Cook Time (minutes)']]

print(df[df['Recipe Name'].isin(update_df['Recipe Name'])]) #check for updated recipes

#To save the file in colab
df.to_csv('updated_recipes.csv', index=False)
files.download('updated_recipes.csv')

# prompt: Search by:
# ○ Recipe name.
# ○ Cuisine (e.g., Italian, Indian, Chinese).
# ○ Ingredients (find recipes using specific ingredients).

import pandas as pd

def search_recipes(df, query, search_by):
    results = pd.DataFrame()
    if search_by == 'Recipe Name':
        results = df[df['Recipe Name'].str.contains(query, case=False, na=False)]
    elif search_by == 'Cuisine':
        results = df[df['Cuisine'].str.contains(query, case=False, na=False)]
    elif search_by == 'Ingredients':
        results = df[df['Ingredients'].str.contains(query, case=False, na=False)]
    return results

# Example usage
search_term = input("Enter search term: ")
search_type = input("Search by (Recipe Name, Cuisine, or Ingredients): ")

search_results = search_recipes(df, search_term, search_type)

if not search_results.empty:
    print(search_results)
else:
    print("No recipes found matching your criteria.")

# prompt: Filter recipes by preparation time (e.g., quick recipes under 30 minutes)

def filter_by_prep_time(df, max_prep_time):
    """Filters recipes based on maximum preparation time.

    Args:
        df: DataFrame containing recipe data.
        max_prep_time: Maximum preparation time in minutes.

    Returns:
        DataFrame containing recipes with preparation time less than or equal to max_prep_time.
    """
    return df[df['Prep Time (minutes)'] <= max_prep_time]

# Example usage (assuming 'df' is your DataFrame):
max_time = 30  # Example: find recipes under 30 minutes
quick_recipes = filter_by_prep_time(df, max_time)
quick_recipes

import pandas as pd

def extract_unique_ingredients(df):
    """
    Extracts and lists all unique ingredients across all recipes in the DataFrame.
    Handles missing values (NaN) in the 'Ingredients' column.
    """
    all_ingredients = []
    for ingredients_str in df['Ingredients']:
        # Check if the value is a string before applying split
        if isinstance(ingredients_str, str):
            ingredients = [ing.strip() for ing in ingredients_str.split(',')]
            all_ingredients.extend(ingredients)
    return set(all_ingredients)

def check_ingredients(df, recipe_name, available_ingredients):
    """
    Checks if the available ingredients are sufficient for a given recipe.
    """
    try:
        recipe_ingredients_str = df.loc[df['Recipe Name'] == recipe_name, 'Ingredients'].iloc[0]
    except IndexError:
        return "Recipe not found."

    # Check if recipe_ingredients_str is a string before applying split
    if isinstance(recipe_ingredients_str, str):
        recipe_ingredients = [ing.strip() for ing in recipe_ingredients_str.split(',')]
        missing_ingredients = set(recipe_ingredients) - set(available_ingredients)

        if missing_ingredients:
          return f"Missing ingredients: {', '.join(missing_ingredients)}"
        else:
          return "You have all the necessary ingredients!"
    else:
        return "Ingredients information is missing for this recipe." # Handle case where ingredients are not a string


# Example usage (assuming 'df' is your DataFrame):
unique_ingredients = extract_unique_ingredients(df)
print("Unique Ingredients:\n", unique_ingredients)

recipe_to_check = input("Enter the name of the recipe to check: ")
user_ingredients = input("Enter your available ingredients (comma-separated): ").split(',')
user_ingredients = [ing.strip() for ing in user_ingredients]

result = check_ingredients(df, recipe_to_check, user_ingredients)
result

# prompt: Generate a shopping list:
# ○ Identify missing ingredients for selected recipes.

def generate_shopping_list(df, selected_recipes, available_ingredients):
    """Generates a shopping list based on selected recipes and available ingredients.

    Args:
        df: DataFrame containing recipe data.
        selected_recipes: A list of recipe names to include in the shopping list.
        available_ingredients: A list of ingredients already available.

    Returns:
        A dictionary where keys are missing ingredients and values are the recipes that require them.
    """

    shopping_list = {}
    for recipe_name in selected_recipes:
        missing = check_ingredients(df, recipe_name, available_ingredients)
        if isinstance(missing, str) and "Missing ingredients:" in missing:
            missing_ingredients = [ing.strip() for ing in missing[missing.find(":") + 2:].split(',')]
            for ingredient in missing_ingredients:
                if ingredient not in shopping_list:
                    shopping_list[ingredient] = []
                shopping_list[ingredient].append(recipe_name)
        elif isinstance(missing, str) and missing != "You have all the necessary ingredients!":
            print(missing) # Print other messages like "Recipe not found."

    return shopping_list


# Example usage (assuming df is your recipe DataFrame):
selected_recipes = ['Chicken Stir-Fry', 'Pasta Carbonara']  # Example selected recipes
available_ingredients = ['Chicken breast', 'Spaghetti', 'Eggs', 'soy sauce']  # Example available ingredients

shopping_list = generate_shopping_list(df, selected_recipes, available_ingredients)

if shopping_list:
    print("Shopping List:")
    for ingredient, recipes in shopping_list.items():
        print(f"- {ingredient} (for: {', '.join(recipes)})")
else:
    print("You have all the ingredients for the selected recipes!")

def categorize_recipes(df):
    """Categorizes recipes based on keywords in the recipe name or ingredients."""

    # Create a new 'Category' column and initialize it to 'Unknown'
    df['Category'] = 'Unknown'

    # Define categories and keywords
    categories = {
        'Appetizer': ['appetizer', 'starter', 'snack'],
        'Main Course': ['main', 'course', 'dinner', 'lunch', 'entree'],
        'Dessert': ['dessert', 'sweet', 'cake', 'pie', 'cookie', 'pastry']
        # Add more categories and keywords as needed
    }

    for index, row in df.iterrows():
        recipe_name = row['Recipe Name'].lower()
        # Check if 'Ingredients' is a string before applying lower()
        ingredients = row['Ingredients'].lower() if isinstance(row['Ingredients'], str) else ''
        for category, keywords in categories.items():
            for keyword in keywords:
                if keyword in recipe_name or keyword in ingredients:
                    df.loc[index, 'Category'] = category
                    break  # Exit keyword loop once a category is assigned
    return df

# prompt: Allow users to plan meals for a week by selecting recipes.

def plan_weekly_meals(df):
    """Allows users to plan meals for a week by selecting recipes."""

    weekly_plan = {}
    for day in ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]:
        print(f"\nPlanning for {day}:")
        while True:
            recipe_name = input("Enter recipe name (or type 'skip' to skip this day or 'done' to finish planning): ")
            if recipe_name.lower() == 'skip':
                break
            elif recipe_name.lower() == 'done':
                return weekly_plan
            elif recipe_name in df['Recipe Name'].values:
                weekly_plan[day] = recipe_name
                break
            else:
                print("Recipe not found. Please try again.")
    return weekly_plan


# Example usage (assuming 'df' is your recipe DataFrame):
weekly_meal_plan = plan_weekly_meals(df)

if weekly_meal_plan:
    print("\nYour weekly meal plan:")
    for day, recipe in weekly_meal_plan.items():
        print(f"{day}: {recipe}")
else:
    print("No meals planned.")

# prompt: Generate a consolidated shopping list for the meal plan.

def generate_shopping_list_from_plan(df, weekly_plan):
    """Generates a consolidated shopping list from a weekly meal plan."""

    all_ingredients = []
    for day, recipe_name in weekly_plan.items():
        try:
            ingredients_str = df.loc[df['Recipe Name'] == recipe_name, 'Ingredients'].iloc[0]
            if isinstance(ingredients_str, str):  # Check if ingredients are a string
              ingredients = [ing.strip() for ing in ingredients_str.split(',')]
              all_ingredients.extend(ingredients)
        except IndexError:
            print(f"Recipe '{recipe_name}' not found in the DataFrame.")
    return set(all_ingredients)  # Return unique ingredients

# Example usage (assuming df and weekly_meal_plan are defined):
consolidated_shopping_list = generate_shopping_list_from_plan(df, weekly_meal_plan)
print("\nConsolidated Shopping List:")
for item in consolidated_shopping_list:
    print(f"- {item}")

# prompt: Export selected recipes or meal plans to a text or CSV file

def export_recipes(df, file_format='txt', selected_recipes=None):
    """Exports selected recipes or all recipes to a text or CSV file.

    Args:
        df: DataFrame containing recipe data.
        file_format: File format for export ('txt' or 'csv').
        selected_recipes: A list of recipe names to export. If None, export all recipes.
    """

    if selected_recipes:
        export_df = df[df['Recipe Name'].isin(selected_recipes)]
    else:
        export_df = df

    if file_format == 'txt':
        filename = 'exported_recipes.txt'
        with open(filename, 'w') as f:
            for index, row in export_df.iterrows():
                f.write(f"Recipe Name: {row['Recipe Name']}\n")
                f.write(f"Ingredients: {row['Ingredients']}\n")
                f.write(f"Steps: {row['Steps']}\n")
                # Add other columns as needed
                f.write("-" * 20 + "\n")  # Separator between recipes
    elif file_format == 'csv':
        filename = 'exported_recipes.csv'
        export_df.to_csv(filename, index=False)
    else:
        print("Invalid file format. Please choose 'txt' or 'csv'.")
        return

    files.download(filename)


# Example usage (assuming 'df' is your DataFrame):
# Export all recipes to a text file
export_recipes(df, file_format='txt')

# Export selected recipes to a CSV file
selected = ['Chicken Stir-Fry', 'Pasta Carbonara']
export_recipes(df, file_format='csv', selected_recipes=selected)

# prompt: Handle issues like duplicate recipes or invalid inputs

# Assuming 'df' is already defined from the previous code block

def add_recipe(df):
    """Adds a new recipe to the DataFrame, handling duplicates and invalid inputs."""

    recipe_name = input("Enter recipe name: ")

    # Check for duplicates
    if recipe_name in df['Recipe Name'].values:
        print("Error: Recipe with this name already exists.")
        return df

    while True:
        try:
            ingredients = input("Enter ingredients (comma-separated): ")
            steps = input("Enter steps: ")
            cuisine = input("Enter cuisine: ")
            prep_time = int(input("Enter preparation time (minutes): "))
            cook_time = int(input("Enter cooking time (minutes): "))

            if prep_time < 0 or cook_time < 0:
                raise ValueError("Times cannot be negative")
            break
        except ValueError as e:
            print(f"Invalid input: {e}. Please try again.")

    new_recipe = {
        'Recipe Name': [recipe_name],
        'Ingredients': [ingredients],
        'Steps': [steps],
        'Cuisine': [cuisine],
        'Prep Time (minutes)': [prep_time],
        'Cook Time (minutes)': [cook_time]
    }
    new_df = pd.DataFrame(new_recipe)
    df = pd.concat([df, new_df], ignore_index=True)
    return df

# Example usage
df = add_recipe(df)
print(df.tail())

# prompt: https://colab.research.google.com/drive/1ULzhEvKGNziWLtk13sHiwYC3KlPNs68g#scrollTo=I_pM5l3icdnO&line=1&uniqifier=1

def delete_recipe(df):
    """Deletes a recipe from the DataFrame based on user input."""

    recipe_name = input("Enter the name of the recipe to delete: ")

    if recipe_name in df['Recipe Name'].values:
        df = df[df['Recipe Name'] != recipe_name]
        print(f"Recipe '{recipe_name}' deleted successfully.")
    else:
        print(f"Recipe '{recipe_name}' not found in the recipe list.")

    return df

# Example usage (assuming df is your recipe DataFrame)
df = delete_recipe(df)
print(df.tail())